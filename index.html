<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Flight Simulator</title>
		<style>
			body { margin: 0; }
			canvas { display: block; }
			#ui-container {
				position: absolute;
				top: 10px;
				left: 10px;
				color: white;
				background-color: rgba(0,0,0,0.5);
				padding: 10px;
				border-radius: 5px;
				font-family: sans-serif;
			}
		</style>
	</head>
	<body>
		<div id="ui-container">
			<div>Speed: <span id="speed">0</span> km/h</div>
			<div>Altitude: <span id="altitude">0</span> m</div>
		</div>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
		<script>
			// Scene
			const scene = new THREE.Scene();
			scene.fog = new THREE.Fog(0xffffff, 1, 500);

			// Sky
			const skyGeometry = new THREE.SphereGeometry(450, 32, 15);
			const skyMaterial = new THREE.ShaderMaterial({
				uniforms: {
					topColor: { value: new THREE.Color(0x0077ff) },
					bottomColor: { value: new THREE.Color(0xffffff) },
					offset: { value: 33 },
					exponent: { value: 0.6 }
				},
				vertexShader: `
					varying vec3 vWorldPosition;
					void main() {
						vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
						vWorldPosition = worldPosition.xyz;
						gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
					}
				`,
				fragmentShader: `
					uniform vec3 topColor;
					uniform vec3 bottomColor;
					uniform float offset;
					uniform float exponent;
					varying vec3 vWorldPosition;
					void main() {
						float h = normalize( vWorldPosition + offset ).y;
						gl_FragColor = vec4( mix( bottomColor, topColor, max( pow( max( h , 0.0), exponent ), 0.0 ) ), 1.0 );
					}
				`,
				side: THREE.BackSide
			});
			const sky = new THREE.Mesh(skyGeometry, skyMaterial);
			scene.add(sky);

			// Camera
			const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
			camera.position.z = 5;
			camera.position.y = 2;

			// Renderer
			const renderer = new THREE.WebGLRenderer();
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.body.appendChild(renderer.domElement);

			// Terrain
			const terrainGeometry = new THREE.PlaneGeometry(100, 100, 50, 50);
			const terrainMaterial = new THREE.MeshBasicMaterial({ color: 0x654321, wireframe: true });
			const terrain = new THREE.Mesh(terrainGeometry, terrainMaterial);
			terrain.rotation.x = -Math.PI / 2;
			scene.add(terrain);

			// Displace vertices to create mountains
			const vertices = terrain.geometry.attributes.position.array;
			for (let i = 0; i <= vertices.length; i += 3) {
				vertices[i+2] = Math.random() * 2;
			}
			terrain.geometry.attributes.position.needsUpdate = true;


			// Trees
			function createTree() {
				const tree = new THREE.Group();

				const trunkGeometry = new THREE.CylinderGeometry(0.1, 0.15, 0.5);
				const trunkMaterial = new THREE.MeshBasicMaterial({ color: 0x8B4513 });
				const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
				tree.add(trunk);

				const leavesGeometry = new THREE.ConeGeometry(0.5, 1.5, 8);
				const leavesMaterial = new THREE.MeshBasicMaterial({ color: 0x006400 });
				const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
				leaves.position.y = 1;
				tree.add(leaves);

				return tree;
			}

			const raycaster = new THREE.Raycaster();
			const trees = [];
			for (let i = 0; i < 200; i++) {
				const x = Math.random() * 90 - 45;
				const z = Math.random() * 90 - 45;
				raycaster.set(new THREE.Vector3(x, 10, z), new THREE.Vector3(0, -1, 0));
				const intersects = raycaster.intersectObject(terrain);
				if (intersects.length > 0) {
					const tree = createTree();
					tree.position.set(x, intersects[0].point.y + 0.25, z);
					tree.scale.setScalar(Math.random() * 0.5 + 0.5);
					scene.add(tree);
					trees.push(tree);
				}
			}

			// Animals
			function createAnimal() {
				const animalGeometry = new THREE.BoxGeometry(0.4, 0.3, 0.6);
				const animalMaterial = new THREE.MeshBasicMaterial({ color: 0xA0522D });
				const animal = new THREE.Mesh(animalGeometry, animalMaterial);
				return animal;
			}

			const animals = [];
			for (let i = 0; i < 50; i++) {
				const x = Math.random() * 90 - 45;
				const z = Math.random() * 90 - 45;
				raycaster.set(new THREE.Vector3(x, 10, z), new THREE.Vector3(0, -1, 0));
				const intersects = raycaster.intersectObject(terrain);
				if (intersects.length > 0) {
					const animal = createAnimal();
					animal.position.set(x, intersects[0].point.y + 0.15, z);
					scene.add(animal);
					animals.push(animal);
				}
			}

			// Birds
			const birds = [];
			for (let i = 0; i < 30; i++) {
				const bird = new THREE.Mesh(new THREE.ConeGeometry(0.1, 0.4, 8), new THREE.MeshBasicMaterial({ color: 0xffffff }));
				bird.position.set(Math.random() * 100 - 50, Math.random() * 5 + 10, Math.random() * 100 - 50);
				bird.velocity = new THREE.Vector3(Math.random() - 0.5, Math.random() * 0.2 - 0.1, Math.random() - 0.5).normalize().multiplyScalar(0.1);
				scene.add(bird);
				birds.push(bird);
			}

			// Airplane
			function createPlane() {
				const plane = new THREE.Group();

				const fuselageGeometry = new THREE.BoxGeometry(0.8, 0.5, 2.5);
				const fuselageMaterial = new THREE.MeshBasicMaterial({ color: 0xd8d8d8 });
				const fuselage = new THREE.Mesh(fuselageGeometry, fuselageMaterial);
				plane.add(fuselage);

				const wingGeometry = new THREE.BoxGeometry(3, 0.1, 0.8);
				const wingMaterial = new THREE.MeshBasicMaterial({ color: 0xb0b0b0 });
				const wing = new THREE.Mesh(wingGeometry, wingMaterial);
				wing.position.y = 0.1;
				plane.add(wing);

				const tailGeometry = new THREE.BoxGeometry(0.2, 0.5, 0.5);
				const tail = new THREE.Mesh(tailGeometry, wingMaterial);
				tail.position.set(0, 0.35, -1.1);
				plane.add(tail);

				const cockpitGeometry = new THREE.BoxGeometry(0.7, 0.4, 0.6);
				const cockpitMaterial = new THREE.MeshBasicMaterial({ color: 0x444444 });
				const cockpit = new THREE.Mesh(cockpitGeometry, cockpitMaterial);
				cockpit.position.set(0, 0.4, 0.7);
				plane.add(cockpit);

				plane.scale.setScalar(0.5);
				return plane;
			}

			const airplane = createPlane();
			airplane.position.set(0, 10, 0);
			scene.add(airplane);

			// Controls & Physics
			const keys = {};
			document.addEventListener('keydown', (e) => keys[e.code] = true);
			document.addEventListener('keyup', (e) => keys[e.code] = false);
			let planeSpeed = 0.1;
			let verticalSpeed = 0;
			const gravity = 0.0003;
			const liftFactor = 0.0005;

			// UI Elements
			const speedElement = document.getElementById('speed');
			const altitudeElement = document.getElementById('altitude');

			// Animation loop
			function animate() {
				requestAnimationFrame(animate);

				// --- Physics & Controls ---
				// Gravity
				verticalSpeed -= gravity;

				// Controls
				if (keys['ArrowUp']) {
					airplane.rotation.x -= 0.01;
					verticalSpeed += liftFactor;
				}
				if (keys['ArrowDown']) {
					airplane.rotation.x += 0.01;
				}
				if (keys['ArrowLeft']) {
					airplane.rotation.z += 0.01;
				}
				if (keys['ArrowRight']) {
					airplane.rotation.z -= 0.01;
				}
				if (keys['KeyW']) {
					planeSpeed += 0.002;
				}
				if (keys['KeyS']) {
					planeSpeed = Math.max(0.01, planeSpeed - 0.002);
				}

				// Update position
				airplane.position.y += verticalSpeed;
				const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(airplane.quaternion);
				airplane.position.add(forward.multiplyScalar(planeSpeed));

				// --- Collision Detection ---
				raycaster.set(airplane.position, new THREE.Vector3(0, -1, 0));
				const intersects = raycaster.intersectObject(terrain);
				if (intersects.length > 0 && intersects[0].distance < 0.5) {
					console.log("Crashed!");
					airplane.position.set(0, 10, 0);
					airplane.rotation.set(0,0,0);
					verticalSpeed = 0;
					planeSpeed = 0.1;
				}

				// Camera follow
				const relativeCameraOffset = new THREE.Vector3(0, 2, 5);
				const cameraOffset = relativeCameraOffset.applyMatrix4(airplane.matrixWorld);
				camera.position.copy(cameraOffset);
				camera.lookAt(airplane.position);

				// Update UI
				speedElement.textContent = Math.floor(planeSpeed * 1000);
				altitudeElement.textContent = Math.floor(airplane.position.y);

				// Animate birds
				birds.forEach(bird => {
					bird.position.add(bird.velocity);
					bird.lookAt(bird.position.clone().add(bird.velocity));
					if (bird.position.distanceTo(airplane.position) > 100) {
						bird.position.set(airplane.position.x + Math.random() * 80 - 40, airplane.position.y + Math.random() * 10, airplane.position.z + Math.random() * 80 - 40);
					}
				});

				renderer.render(scene, camera);
			}
			animate();

			// Handle window resize
			window.addEventListener('resize', () => {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize(window.innerWidth, window.innerHeight);
			}, false);
		</script>
	</body>
</html>
